---
sidebar: sidebar 
permalink: trident-protect/trident-protect-restore-apps.html 
keywords: trident, protect, restore, data, backup 
summary: 'Vous pouvez utiliser Trident Protect pour restaurer votre application à partir d"une copie Snapshot ou d"une sauvegarde. La restauration d"un snapshot existant est plus rapide lors de la restauration d"une application sur le même cluster.' 
---
= Restaurez les applications à l'aide de Trident Protect
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ../media/


[role="lead"]
Vous pouvez utiliser Trident Protect pour restaurer votre application à partir d'une copie Snapshot ou d'une sauvegarde. La restauration d'un snapshot existant est plus rapide lors de la restauration d'une application sur le même cluster.


NOTE: Lorsque vous restaurez une application, tous les crochets d'exécution configurés pour l'application sont restaurés avec l'application. Si un hook d'exécution post-restauration est présent, il s'exécute automatiquement dans le cadre de l'opération de restauration.



== Annotations et étiquettes de namespace pendant les opérations de restauration et de basculement

Lors des opérations de restauration et de basculement, les libellés et les annotations dans l'espace de noms de destination correspondent aux libellés et aux annotations dans l'espace de noms source. Des étiquettes ou des annotations provenant de l'espace de noms source qui n'existent pas dans l'espace de noms de destination sont ajoutées et toutes les étiquettes ou annotations qui existent déjà sont écrasées pour correspondre à la valeur de l'espace de noms source. Les libellés ou annotations qui existent uniquement dans l'espace de noms de destination restent inchangés.


NOTE: Si vous utilisez RedHat OpenShift, il est important de noter le rôle critique des annotations d'espace de noms dans les environnements OpenShift. Les annotations de l'espace de noms garantissent que les pods restaurés respectent les autorisations et les configurations de sécurité appropriées définies par les contraintes de contexte de sécurité (CSC) OpenShift et qu'ils peuvent accéder aux volumes sans problèmes d'autorisation. Pour plus d'informations, reportez-vous au https://docs.redhat.com/en/documentation/openshift_container_platform/4.17/html/authentication_and_authorization/managing-pod-security-policies["Documentation sur les contraintes de contexte de sécurité OpenShift"^].

Vous pouvez empêcher l'écrasement d'annotations spécifiques dans l'espace de noms de destination en configurant la variable d'environnement Kubernetes `RESTORE_SKIP_NAMESPACE_ANNOTATIONS` avant d'effectuer l'opération de restauration ou de basculement. Par exemple :

[source, console]
----
kubectl set env -n trident-protect deploy/trident-protect-controller-manager RESTORE_SKIP_NAMESPACE_ANNOTATIONS=<annotation_key_to_skip_1>,<annotation_key_to_skip_2>
----
Si vous avez installé l'application source à l'aide de Helm avec l' `--create-namespace`indicateur, un traitement spécial est donné à la `name` clé d'étiquette. Lors du processus de restauration ou de basculement, Trident Protect copie cette étiquette dans l'espace de noms de destination, mais met à jour la valeur vers la valeur de l'espace de noms de destination si la valeur de la source correspond à l'espace de noms source. Si cette valeur ne correspond pas à l'espace de noms source, elle est copiée dans l'espace de noms de destination sans modification.



=== Exemple

L'exemple suivant présente un espace de noms source et de destination, chacun avec des annotations et des libellés différents. Vous pouvez voir l'état de l'espace de noms de destination avant et après l'opération, ainsi que la manière dont les annotations et les étiquettes sont combinées ou écrasées dans l'espace de noms de destination.



==== Avant l'opération de restauration ou de basculement

Le tableau suivant illustre l'état de l'exemple d'espaces de noms source et de destination avant l'opération de restauration ou de basculement :

[cols="1,2a,2a"]
|===
| Espace de noms | Annotations | Étiquettes 


| Espace de noms ns-1 (source)  a| 
* annotation.one/key : « updatedvalue »
* annotation.deux/touche : « vrai »

 a| 
* environnement=production
* conformité = hipaa
* name=ns-1




| Espace de noms ns-2 (destination)  a| 
* annotation.un/touche : « vrai »
* annotation.trois/touche : « false »

 a| 
* role=base de données


|===


==== Après l'opération de restauration

Le tableau suivant illustre l'état de l'exemple d'espace de noms de destination après une opération de restauration ou de basculement. Certaines clés ont été ajoutées, d'autres ont été écrasées et le `name` libellé a été mis à jour pour correspondre à l'espace de noms de destination :

[cols="1,2a,2a"]
|===
| Espace de noms | Annotations | Étiquettes 


| Espace de noms ns-2 (destination)  a| 
* annotation.one/key : « updatedvalue »
* annotation.deux/touche : « vrai »
* annotation.trois/touche : « false »

 a| 
* name=ns-2
* conformité = hipaa
* environnement=production
* role=base de données


|===


== Restauration d'une sauvegarde vers un autre espace de noms

Lorsque vous restaurez une sauvegarde dans un espace de noms différent à l'aide d'une sauvegarde CR BackupRestore, Trident Protect restaure l'application dans un nouvel espace de noms, mais l'application restaurée n'est pas automatiquement protégée par Trident Protect. Pour protéger l'application restaurée, vous devez créer une application CR pour l'application restaurée afin qu'elle soit protégée par Trident Protect.


NOTE: La restauration d'une sauvegarde dans un espace de noms différent avec des ressources existantes ne modifie aucune ressource qui partage des noms avec ceux de la sauvegarde. Pour restaurer toutes les ressources de la sauvegarde, supprimez et recréez l'espace de noms cible ou restaurez la sauvegarde dans un nouvel espace de noms.

[role="tabbed-block"]
====
.Utiliser une CR
--
.Étapes
. Créez le fichier de ressource personnalisée (CR) et nommez-le `trident-protect-backup-restore-cr.yaml`.
. Dans le fichier que vous avez créé, configurez les attributs suivants :
+
** *metadata.name*: (_required_) le nom de cette ressource personnalisée; choisissez un nom unique et sensible pour votre environnement.
** *Spec.appArchivePath* : chemin d'accès dans AppVault où sont stockés le contenu de la sauvegarde. Vous pouvez utiliser la commande suivante pour trouver ce chemin :
+
[source, console]
----
kubectl get backups <BACKUP_NAME> -n my-app-namespace -o jsonpath='{.status.appArchivePath}'
----
** *Spec.appVaultRef*: (_required_) Nom de l'AppVault où sont stockés le contenu de la sauvegarde.
** *spec.namespaceMapping*: mappage de l'espace de noms source de l'opération de restauration sur l'espace de noms de destination. Remplacez `my-source-namespace` et `my-destination-namespace` par des informations provenant de votre environnement.
** *Spec.storageClassMapping* : mappage de la classe de stockage source de l'opération de restauration à la classe de stockage de destination. Remplacez `destinationStorageClass` et `sourceStorageClass` par des informations provenant de votre environnement.
+
[source, yaml]
----
apiVersion: protect.trident.netapp.io/v1o
kind: BackupRestore
metadata:
  name: my-cr-name
  namespace: my-destination-namespace
spec:
  appArchivePath: my-backup-path
  appVaultRef: appvault-name
  namespaceMapping: [{"source": "my-source-namespace", "destination": "my-destination-namespace"}]
  storageClassMapping:
    destination: "${destinationStorageClass}"
    source: "${sourceStorageClass}"
----


. (_Facultatif_) si vous devez sélectionner uniquement certaines ressources de l'application à restaurer, ajoutez un filtrage qui inclut ou exclut les ressources marquées avec des étiquettes particulières :
+
** *ResourceFilter.resourceSelectionCriteria*: (Requis pour le filtrage) utilisez `include or exclude` pour inclure ou exclure une ressource définie dans resourceMatchers. Ajoutez les paramètres resourceMatchers suivants pour définir les ressources à inclure ou à exclure :
+
*** *ResourceFilter.resourceMatchers* : tableau des objets resourceMatcher.
+
**** *ResourceMatchers[].group*: (_Optional_) Groupe de la ressource à filtrer.
**** *ResourceMatchers[].kind*: (_Optional_) Type de la ressource à filtrer.
**** *ResourceMatchers[].version*: (_Optional_) version de la ressource à filtrer.
**** *ResourceMatchers[].names*: (_Optional_) noms dans le champ Kubernetes metadata.name de la ressource à filtrer.
**** *ResourceMatchers[].namespaces*: (_Optional_) Namespaces dans le champ Kubernetes metadata.name de la ressource à filtrer.
**** *ResourceMatchers[].labelSelectors*: (_Optional_) chaîne de sélecteur de libellé dans le champ Kubernetes metadata.name de la ressource, comme défini dans le https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors["Documentation Kubernetes"^]. Par exemple : `"trident.netapp.io/os=linux"`.
+
Par exemple :

+
[source, yaml]
----
spec:
  resourceFilter:
    resourceSelectionCriteria: "include"
    resourceMatchers:
      group: my-resource-group
      kind: my-resource-kind
      version: my-resource-version
      names: ["my-resource-names"]
      namespaces: ["my-resource-namespaces"]
      labelSelectors: ["trident.netapp.io/os=linux"]
----






. Une fois que vous avez rempli le `trident-protect-backup-restore-cr.yaml` fichier avec les valeurs correctes, appliquez la CR :
+
[source, console]
----
kubectl apply -f trident-protect-backup-restore-cr.yaml
----


--
.Utiliser l'interface de ligne de commande
--
.Étapes
. Restaurez la sauvegarde dans un espace de noms différent, en remplaçant les valeurs entre parenthèses par les informations de votre environnement. L' `namespace-mapping`argument utilise des espaces de noms séparés par deux-points pour mapper les espaces de noms source aux espaces de noms de destination corrects dans le format `source1:dest1,source2:dest2`. Par exemple :
+
[source, console]
----
tridentctl protect create backuprestore <my_restore_name> --backup <backup_namespace>/<backup_to_restore> --namespace-mapping <source_to_destination_namespace_mapping>
----


--
====


== Restaurer à partir d'une sauvegarde vers l'espace de noms d'origine

Vous pouvez à tout moment restaurer une sauvegarde dans l'espace de noms d'origine.

[role="tabbed-block"]
====
.Utiliser une CR
--
.Étapes
. Créez le fichier de ressource personnalisée (CR) et nommez-le `trident-protect-backup-ipr-cr.yaml`.
. Dans le fichier que vous avez créé, configurez les attributs suivants :
+
** *metadata.name*: (_required_) le nom de cette ressource personnalisée; choisissez un nom unique et sensible pour votre environnement.
** *Spec.appArchivePath* : chemin d'accès dans AppVault où sont stockés le contenu de la sauvegarde. Vous pouvez utiliser la commande suivante pour trouver ce chemin :
+
[source, console]
----
kubectl get backups <BACKUP_NAME> -n my-app-namespace -o jsonpath='{.status.appArchivePath}'
----
** *Spec.appVaultRef*: (_required_) Nom de l'AppVault où sont stockés le contenu de la sauvegarde.
+
Par exemple :

+
[source, yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: BackupInplaceRestore
metadata:
  name: my-cr-name
  namespace: my-app-namespace
spec:
  appArchivePath: my-backup-path
  appVaultRef: appvault-name
----


. (_Facultatif_) si vous devez sélectionner uniquement certaines ressources de l'application à restaurer, ajoutez un filtrage qui inclut ou exclut les ressources marquées avec des étiquettes particulières :
+
** *ResourceFilter.resourceSelectionCriteria*: (Requis pour le filtrage) utilisez `include or exclude` pour inclure ou exclure une ressource définie dans resourceMatchers. Ajoutez les paramètres resourceMatchers suivants pour définir les ressources à inclure ou à exclure :
+
*** *ResourceFilter.resourceMatchers* : tableau des objets resourceMatcher.
+
**** *ResourceMatchers[].group*: (_Optional_) Groupe de la ressource à filtrer.
**** *ResourceMatchers[].kind*: (_Optional_) Type de la ressource à filtrer.
**** *ResourceMatchers[].version*: (_Optional_) version de la ressource à filtrer.
**** *ResourceMatchers[].names*: (_Optional_) noms dans le champ Kubernetes metadata.name de la ressource à filtrer.
**** *ResourceMatchers[].namespaces*: (_Optional_) Namespaces dans le champ Kubernetes metadata.name de la ressource à filtrer.
**** *ResourceMatchers[].labelSelectors*: (_Optional_) chaîne de sélecteur de libellé dans le champ Kubernetes metadata.name de la ressource, comme défini dans le https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors["Documentation Kubernetes"^]. Par exemple : `"trident.netapp.io/os=linux"`.
+
Par exemple :

+
[source, yaml]
----
spec:
  resourceFilter:
    resourceSelectionCriteria: "include"
    resourceMatchers:
      group: my-resource-group
      kind: my-resource-kind
      version: my-resource-version
      names: ["my-resource-names"]
      namespaces: ["my-resource-namespaces"]
      labelSelectors: ["trident.netapp.io/os=linux"]
----






. Une fois que vous avez rempli le `trident-protect-backup-ipr-cr.yaml` fichier avec les valeurs correctes, appliquez la CR :
+
[source, console]
----
kubectl apply -f trident-protect-backup-ipr-cr.yaml
----


--
.Utiliser l'interface de ligne de commande
--
.Étapes
. Restaurez la sauvegarde dans l'espace de noms d'origine en remplaçant les valeurs entre parenthèses par les informations de votre environnement. L' `backup`argument utilise un nom d'espace de noms et un nom de sauvegarde au format `<namespace>/<name>`. Par exemple :
+
[source, console]
----
tridentctl protect create backupinplacerestore <my_restore_name> --backup <namespace/backup_to_restore>
----


--
====


== Restauration d'un snapshot vers un autre espace de noms

Vous pouvez restaurer les données d'un instantané à l'aide d'un fichier de ressource personnalisée (CR) dans un espace de noms différent ou dans l'espace de noms source d'origine. Lorsque vous restaurez un snapshot sur un autre espace de noms à l'aide d'un CR SnapshotRestore, Trident Protect restaure l'application dans un nouvel espace de noms, mais l'application restaurée n'est pas automatiquement protégée par Trident Protect. Pour protéger l'application restaurée, vous devez créer une application CR pour l'application restaurée afin qu'elle soit protégée par Trident Protect.

[role="tabbed-block"]
====
.Utiliser une CR
--
.Étapes
. Créez le fichier de ressource personnalisée (CR) et nommez-le `trident-protect-snapshot-restore-cr.yaml`.
. Dans le fichier que vous avez créé, configurez les attributs suivants :
+
** *metadata.name*: (_required_) le nom de cette ressource personnalisée; choisissez un nom unique et sensible pour votre environnement.
** *Spec.appVaultRef*: (_required_) le nom du AppVault dans lequel le contenu de l'instantané est stocké.
** *Spec.appArchivePath* : chemin d'accès dans AppVault où sont stockés le contenu de l'instantané. Vous pouvez utiliser la commande suivante pour trouver ce chemin :
+
[source, console]
----
kubectl get snapshots <SNAPHOT_NAME> -n my-app-namespace -o jsonpath='{.status.appArchivePath}'
----
** *spec.namespaceMapping*: mappage de l'espace de noms source de l'opération de restauration sur l'espace de noms de destination. Remplacez `my-source-namespace` et `my-destination-namespace` par des informations provenant de votre environnement.
** *Spec.storageClassMapping* : mappage de la classe de stockage source de l'opération de restauration à la classe de stockage de destination. Remplacez `destinationStorageClass` et `sourceStorageClass` par des informations provenant de votre environnement.
+
[source, yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: SnapshotRestore
metadata:
  name: my-cr-name
  namespace: my-app-namespace
spec:
  appVaultRef: appvault-name
  appArchivePath: my-snapshot-path
  namespaceMapping: [{"source": "my-source-namespace", "destination": "my-destination-namespace"}]
  storageClassMapping:
    destination: "${destinationStorageClass}"
    source: "${sourceStorageClass}"
----


. (_Facultatif_) si vous devez sélectionner uniquement certaines ressources de l'application à restaurer, ajoutez un filtrage qui inclut ou exclut les ressources marquées avec des étiquettes particulières :
+
** *ResourceFilter.resourceSelectionCriteria*: (Requis pour le filtrage) utilisez `include or exclude` pour inclure ou exclure une ressource définie dans resourceMatchers. Ajoutez les paramètres resourceMatchers suivants pour définir les ressources à inclure ou à exclure :
+
*** *ResourceFilter.resourceMatchers* : tableau des objets resourceMatcher.
+
**** *ResourceMatchers[].group*: (_Optional_) Groupe de la ressource à filtrer.
**** *ResourceMatchers[].kind*: (_Optional_) Type de la ressource à filtrer.
**** *ResourceMatchers[].version*: (_Optional_) version de la ressource à filtrer.
**** *ResourceMatchers[].names*: (_Optional_) noms dans le champ Kubernetes metadata.name de la ressource à filtrer.
**** *ResourceMatchers[].namespaces*: (_Optional_) Namespaces dans le champ Kubernetes metadata.name de la ressource à filtrer.
**** *ResourceMatchers[].labelSelectors*: (_Optional_) chaîne de sélecteur de libellé dans le champ Kubernetes metadata.name de la ressource, comme défini dans le https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors["Documentation Kubernetes"^]. Par exemple : `"trident.netapp.io/os=linux"`.
+
Par exemple :

+
[source, yaml]
----
spec:
  resourceFilter:
    resourceSelectionCriteria: "include"
    resourceMatchers:
      group: my-resource-group
      kind: my-resource-kind
      version: my-resource-version
      names: ["my-resource-names"]
      namespaces: ["my-resource-namespaces"]
      labelSelectors: ["trident.netapp.io/os=linux"]
----






. Une fois que vous avez rempli le `trident-protect-snapshot-restore-cr.yaml` fichier avec les valeurs correctes, appliquez la CR :
+
[source, console]
----
kubectl apply -f trident-protect-snapshot-restore-cr.yaml
----


--
.Utiliser l'interface de ligne de commande
--
.Étapes
. Restaurez l'instantané dans un autre espace de noms, en remplaçant les valeurs entre parenthèses par les informations de votre environnement.
+
** L' `snapshot`argument utilise un nom d'espace de noms et un nom d'instantané au format `<namespace>/<name>`.
** L' `namespace-mapping`argument utilise des espaces de noms séparés par deux-points pour mapper les espaces de noms source aux espaces de noms de destination corrects dans le format `source1:dest1,source2:dest2`.
+
Par exemple :

+
[source, console]
----
tridentctl protect create snapshotrestore <my_restore_name> --snapshot <namespace/snapshot_to_restore> --namespace-mapping <source_to_destination_namespace_mapping>
----




--
====


== Restaurer à partir d'un snapshot vers l'espace de noms d'origine

Vous pouvez à tout moment restaurer un snapshot dans l'espace de noms d'origine.

[role="tabbed-block"]
====
.Utiliser une CR
--
.Étapes
. Créez le fichier de ressource personnalisée (CR) et nommez-le `trident-protect-snapshot-ipr-cr.yaml`.
. Dans le fichier que vous avez créé, configurez les attributs suivants :
+
** *metadata.name*: (_required_) le nom de cette ressource personnalisée; choisissez un nom unique et sensible pour votre environnement.
** *Spec.appVaultRef*: (_required_) le nom du AppVault dans lequel le contenu de l'instantané est stocké.
** *Spec.appArchivePath* : chemin d'accès dans AppVault où sont stockés le contenu de l'instantané. Vous pouvez utiliser la commande suivante pour trouver ce chemin :
+
[source, console]
----
kubectl get snapshots <SNAPSHOT_NAME> -n my-app-namespace -o jsonpath='{.status.appArchivePath}'
----
+
[source, yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: SnapshotInplaceRestore
metadata:
  name: my-cr-name
  namespace: my-app-namespace
spec:
  appVaultRef: appvault-name
    appArchivePath: my-snapshot-path
----


. (_Facultatif_) si vous devez sélectionner uniquement certaines ressources de l'application à restaurer, ajoutez un filtrage qui inclut ou exclut les ressources marquées avec des étiquettes particulières :
+
** *ResourceFilter.resourceSelectionCriteria*: (Requis pour le filtrage) utilisez `include or exclude` pour inclure ou exclure une ressource définie dans resourceMatchers. Ajoutez les paramètres resourceMatchers suivants pour définir les ressources à inclure ou à exclure :
+
*** *ResourceFilter.resourceMatchers* : tableau des objets resourceMatcher.
+
**** *ResourceMatchers[].group*: (_Optional_) Groupe de la ressource à filtrer.
**** *ResourceMatchers[].kind*: (_Optional_) Type de la ressource à filtrer.
**** *ResourceMatchers[].version*: (_Optional_) version de la ressource à filtrer.
**** *ResourceMatchers[].names*: (_Optional_) noms dans le champ Kubernetes metadata.name de la ressource à filtrer.
**** *ResourceMatchers[].namespaces*: (_Optional_) Namespaces dans le champ Kubernetes metadata.name de la ressource à filtrer.
**** *ResourceMatchers[].labelSelectors*: (_Optional_) chaîne de sélecteur de libellé dans le champ Kubernetes metadata.name de la ressource, comme défini dans le https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors["Documentation Kubernetes"^]. Par exemple : `"trident.netapp.io/os=linux"`.
+
Par exemple :

+
[source, yaml]
----
spec:
  resourceFilter:
    resourceSelectionCriteria: "include"
    resourceMatchers:
      group: my-resource-group
      kind: my-resource-kind
      version: my-resource-version
      names: ["my-resource-names"]
      namespaces: ["my-resource-namespaces"]
      labelSelectors: ["trident.netapp.io/os=linux"]
----






. Une fois que vous avez rempli le `trident-protect-snapshot-ipr-cr.yaml` fichier avec les valeurs correctes, appliquez la CR :
+
[source, console]
----
kubectl apply -f trident-protect-snapshot-ipr-cr.yaml
----


--
.Utiliser l'interface de ligne de commande
--
.Étapes
. Restaurez l'instantané dans l'espace de noms d'origine en remplaçant les valeurs entre parenthèses par les informations de votre environnement. Par exemple :
+
[source, console]
----
tridentctl protect create snapshotinplacerestore <my_restore_name> --snapshot <snapshot_to_restore>
----


--
====


== Vérifiez l'état d'une opération de restauration

Vous pouvez utiliser la ligne de commande pour vérifier l'état d'une opération de restauration en cours, terminée ou ayant échoué.

.Étapes
. Utilisez la commande suivante pour récupérer le statut de l'opération de restauration en remplaçant les valeurs entre crochets par des informations de votre environnement :
+
[source, console]
----
kubectl get backuprestore -n <namespace_name> <my_restore_cr_name> -o jsonpath='{.status}'
----

